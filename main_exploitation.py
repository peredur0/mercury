#! /usr/bin/env python3
# coding: utf-8

"""
Phase 2: Exploitation (pour chaque document, pour tous les SPAM, HAM et pour tout les documents)
  Données statistiques:
    - Distribution de ZIPF
        Le mot le plus fréquent est 2 fois plus présent que le 2, 3 fois plus que le 3e etc
    - Distribution selon la taille des mots
        > Pour les textes aléatoires les mots les plus courts sont plus fréquent
    - Proportion d'HAPAX (la proportion de mot n'ayant qu'une seule occurence doit être vers 50%)

    ==> Résultat avec ou sans analyse syntaxique (Standford ou nltk)
    ==> Système de scoring ELK pour les mails, sqlite pour les catégories

  Données sémantiques
    - Extraction des thèmes
"""
import re
import sys

from databases import elastic_cmd, psql_cmd
from databases.elastic import secrets as es_secrets
from databases.psql_db import secrets as ps_secrets


def recup_mails(es_index):
    """
    Récuperation des mails dans la base psql
    :param es_index: <str> nom de l'index ES où recupérer les données
    :return: <dict> Dictionnaire avec les données des mails
    """
    es_cli = elastic_cmd.es_connect(es_secrets.serveur, (es_secrets.apiid, es_secrets.apikey),
                                    es_secrets.ca_cert)
    data = {}
    for cat in ['spam', 'ham']:
        print("-- Récupération des {}...".format(cat), end=' ')
        data[cat] = {entry.get('_source').get('hash'): entry.get('_source').get('message')
                     for entry in elastic_cmd.es_get_all(es_cli, es_index, sort={'hash': 'asc'},
                                                         query={'match': {'categorie': cat}})}
        print('OK')
    return data


def stats_ponct(texte):
    """
    Genere les stats pour la table de ponctuation
        points, virgule, espaces, lignes
    :param texte: <str> texte a analyser
    :return: <dict> données e stocker en base
    """
    return {"point": texte.count('.'),
            "virgule": texte.count(','),
            "exclamation": texte.count('!'),
            "interrogation": texte.count('?'),
            "tabulation": texte.count('\t'),
            "espace": texte.count(' '),
            "ligne": texte.count('\n') + 1,
            "ligne_vide": len(re.findall(r'^\s*$', texte, re.MULTILINE))
            }


def stats_mot(texte):
    """
    Genere les stats pour la table des mots
        mots, char non vide
    :param texte: <str> texte a analyser
    :return: <dict> avec les données
    """
    tokens = re.findall(r'\w+', texte, re.MULTILINE)
    # Meilleure méthode que pour le comptage des mots fait avec un simple split dans la phase 1.
    return {
        'char_min': len(re.findall(r'[a-z]', texte, re.MULTILINE)),
        'char_maj': len(re.findall(r'[A-Z]', texte, re.MULTILINE)),
        'mots': len(tokens),
        'mots_uniques': len(set(tokens)),
        'mot_maj': sum(mot.isupper() for mot in tokens),
        'mot_cap': sum(bool(re.match(r'[A-Z][a-z]+', mot)) for mot in tokens)
    }


def stats_pipe(hash_message, message, psql_cli):
    """
    Pipeline des statistiques
    :param hash_message: <str> identifiant unique du message
    :param message: <str> message à analyser
    :param psql_cli: <psycopg2.extension.connection> client PSQL
    :return: <None>
    """
    resp = psql_cmd.get_data(psql_cli, 'messages', ['id_message'], f"hash LIKE '{hash_message}'")
    if not resp:
        print(f"No id_message found for {hash_message}", file=sys.stderr)
        return
    id_mess = resp[0].get('id_message')

    # -- Insertion donnee de ponctuation
    resp = psql_cmd.get_data(psql_cli, 'stat_ponct', ['id_message'], f"id_message={id_mess}")
    if resp:
        print(f"Data already there for {id_mess}:{hash_message} in stat_ponct", file=sys.stderr)
        return

    s_ponct = stats_ponct(message)

    # -- Insertion donnees de mots
    resp = psql_cmd.get_data(psql_cli, 'stats_mots', ['id_message'], f"id_message={id_mess}")
    if resp:
        print(f"Data already there for {id_mess}:{hash_message}, in stats_mots", file=sys.stderr)
        return
    s_mots = stats_mot(message)


if __name__ == '__main__':
    print("=== Phase 2 : Stats Exploitation ===")

    dev_data = recup_mails('test_import_dev0')
    psql_cli = psql_cmd.connect_db('mail_features', ps_secrets.admin, ps_secrets.admin_pw,
                                   ps_secrets.host, ps_secrets.port)

    for key, value in dev_data['spam'].items():
        stats_pipe(key, value, psql_cli)

    # psql_cli.close()

